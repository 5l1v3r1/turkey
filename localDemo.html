<!-- Local demo for identical UI deployed on Amazon MTurk; open in browser -->

<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
        crossorigin="anonymous">
    <style>
        #parent {
            width: 1000px;
            overflow: hidden;
            position: relative;
            background: white;
        }

        #myCanvas {
            position: absolute;
        }

        #pic {
            width: 100%;
            height: auto;
        }
    </style>

    <title>Hello, world!</title>
</head>

<body>
    <div style="display:inline-block;vertical-align:top;">
        <h1>turkey local demo</h1>

        <ul>
            <li>Press <b>Left Click</b> to draw a point</li>
            <li>Press <b>Mode Button</b> to toggle mode</li>
            <li>Press <strong>CTRL+Z</strong> to undo.</li>
            <li>Press <strong>C</strong> to close polygon in polygon mode.</li>
            <li>Press <strong>Reset</strong> to clear everything.</li>
            <li><b>Dot mode</b> indicates the location of the object with one click. </li>
            <li><b>Link mode</b> indicates head (1st click) and tail (2nd click).</li>
            <li><b>Polygon mode</b> draws the segmentation mask of the object.</li>
        </ul>
    </div>

    <p id="buttons">
        <input class="btn btn-secondary" id="undo_button" type="button" value="Undo" />
        <input class="btn btn-danger" id="reset_button" type="Reset" value="Reset" />
        <input class="btn btn-info" id="mode_button" type="button" value="Dot Mode" />
    </p>

    <div id="parent">
        <div id="child">
            <canvas id="myCanvas" style="border:1px solid red;">
            </canvas>
            <img id='pic' src="https://cdn.static-economist.com/sites/default/files/images/print-edition/20180203_BRP004_0.jpg" />
        </div>
    </div>

    <script>
        var translateX, translateY, delta, scaleRatio, scaleDiff;
        var anchorX, anchorY, dragged, dragStart, dragX, dragY;
        var perimeter = new Array();
        var perimeters = new Array();
        var dragOffsetX = 0;
        var dragOffsetY = 0;
        var scalingOffsetX = 0;
        var scalingOffsetY = 0;
        var mouseX, mouseY;
        var oldScale = 1.0;
        var newScale = 1.0;
        var child, parent, canvas, ctx, img;
        var firstPoint = true;
        var modeNum = 0;

        var handleScroll = function (evt) {
            delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.detail ? -evt.detail : 0;

            newScale += delta / 10;
            newScale = Math.max(newScale, 1.0);
            newScale = Math.min(newScale, 5.0);
            scaleRatio = newScale / oldScale;
            scaleDiff = newScale - oldScale;
            oldScale = newScale;

            scalingOffsetX = (newScale - 1) * 0.5 * parent.offsetWidth;
            scalingOffsetY = (newScale - 1) * 0.5 * parent.offsetHeight;

            child.style.transform += 'scale(' + scaleRatio + ', ' + scaleRatio + ')';

            getCorrectCoords(evt);

            return evt.preventDefault() && false;
        };

        function getCorrectCoords(evt) {
            mouseX = evt.clientX - parent.offsetLeft;
            mouseY = evt.clientY - parent.offsetTop;
            correctX = (mouseX + scalingOffsetX - dragOffsetX) / newScale;
            correctY = (mouseY + scalingOffsetY - dragOffsetY) / newScale;

            correctX = Math.round(correctX);
            correctY = Math.round(correctY);
        }

        window.onload = function () {
            parent = document.getElementById("parent");
            child = document.getElementById("child");
            canvas = document.getElementById("myCanvas");
            ctx = canvas.getContext("2d");
            img = document.getElementById("pic");
            modeButton = document.getElementById("mode_button");
            canvas.width = img.width;
            canvas.height = img.height;
            // parent.style.width = img.width + 'px';
            // parent.style.height = img.height + 'px';
            ctx.fillStyle = "red";
            ctx.strokeStyle = "red";

            //initialize buttons
            $("#reset_button").click(function (e) {
                reset();
            });
            $("#undo_button").click(function (e) {
                undo();
            });
            $("#mode_button").click(function (e) {
                toggleMode();
            });


            child.addEventListener('DOMMouseScroll', handleScroll, false);
            child.addEventListener('mousewheel', handleScroll, false);

            canvas.addEventListener('mouseup', function (evt) {
                mouseX = evt.clientX - parent.offsetLeft;
                mouseY = evt.clientY - parent.offsetTop;
                if (!dragged) {
                    switch (modeNum) {
                        case 0: // dot mode
                            perimeters.push([correctX, correctY]);
                            ctx.fillRect(correctX - 1, correctY - 1, 2, 2);
                            break;
                        case 1: // link mode
                            perimeter.push([correctX, correctY]);
                            if (firstPoint) {
                                firstPoint = false;
                                ctx.fillRect(correctX - 1, correctY - 1, 2, 2);
                            } else {
                                perimeters.push(perimeter);
                                ctx.beginPath();
                                ctx.moveTo(perimeter[0][0], perimeter[0][1]);
                                ctx.lineTo(perimeter[1][0], perimeter[1][1]);
                                ctx.closePath();
                                ctx.stroke();
                                ctx.fillRect(correctX - 1, correctY - 1, 2, 2);
                                perimeter = new Array();
                                firstPoint = true;
                            }
                            break;
                        case 2: // polygon mode
                            perimeter.push([correctX, correctY]);
                            ctx.fillRect(correctX - 1, correctY - 1, 2, 2);
                    }
                }
                dragStart = false;
            }, false);


            canvas.addEventListener('mousemove', function (evt) {
                if (dragStart) {
                    dragged = true;
                    dragX = evt.clientX - anchorX;
                    dragY = evt.clientY - anchorY;
                    child.style.transform += 'translate(' + dragX / newScale + 'px, ' + dragY / newScale + 'px)';
                    dragOffsetX += dragX;
                    dragOffsetY += dragY;
                    console.log(dragOffsetX, dragOffsetY);
                    anchorX = evt.clientX;
                    anchorY = evt.clientY;
                }
                getCorrectCoords(evt);
            }, false);

            canvas.addEventListener('mousedown', function (evt) {
                anchorX = evt.clientX;
                anchorY = evt.clientY;
                dragged = false;
                dragStart = true;
            }, false);

            function toggleMode() {
                modeNum += 1;
                if (modeNum > 2) {
                    modeNum = 0;
                }
                switch (modeNum) {
                    case 0:
                        modeButton.value = "Dot Mode";
                        break;
                    case 1:
                        modeButton.value = "Link Mode";
                        break;
                    case 2:
                        modeButton.value = "Polygon Mode";
                }
            }
            function reset() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                firstPoint = true;
                perimeters = new Array();
                perimeter = new Array();
            }
            function undo() {
                if (perimeter.length == 0) {
                    perimeters.pop();
                } else {
                    perimeter.pop();
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                switch (modeNum) {
                    case 0: // dot mode
                        for (var i = 0; i < perimeters.length; i++) {
                            var ps = perimeters[i];
                            ctx.fillRect(ps[0] - 1, ps[1] - 1, 2, 2);
                        }
                        break;
                    case 1: // link mode
                        for (var i = 0; i < perimeters.length; i++) {
                            var ps = perimeters[i];
                            ctx.fillRect(ps[0][0] - 1, ps[0][1] - 1, 2, 2);
                            ctx.fillRect(ps[1][0] - 1, ps[1][1] - 1, 2, 2);

                            // If there is only beginPath() without closePath(), then when 
                            // the canvas is cleared, those erased paths will reappear
                            // whenever fill() or stroke() is called again! 
                            ctx.beginPath();
                            ctx.moveTo(ps[0][0], ps[0][1]);
                            ctx.lineTo(ps[1][0], ps[1][1]);
                            ctx.closePath();
                            ctx.stroke();
                        }
                        ctx.fillRect(perimeter[0] - 1, perimeter[1] - 1, 2, 2);
                        break;
                    case 2: // polygon mode
                        for (var i = 0; i < perimeter.length; i++) {
                            ctx.fillRect(perimeter[i][0] - 1, perimeter[i][1] - 1, 2, 2);
                        }
                        ctx.fillStyle = "red";
                        for (var i = 0; i < perimeters.length; i++) {
                            var ps = perimeters[i];
                            ctx.beginPath();
                            ctx.moveTo(ps[0][0], ps[0][1]);
                            for (var j = 1; j < ps.length; j++) {
                                console.log("P");
                                ctx.lineTo(ps[j][0], ps[j][1]);
                                ctx.stroke();
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                }
            }

            window.addEventListener("keydown", function (evt) {
                // Press E for "Mode toggle"
                if (evt.key == 'e') {
                    toggleMode();
                }

                // Press ctrl + Z for "Undo"
                if ((evt.key == 'z') && (evt.ctrlKey)) {
                    undo();
                }

                // Press C for "Close Polygon"
                if (evt.key == 'c') {
                    console.log("C");
                    if (perimeter.length != 0) {
                        perimeters.push(perimeter);
                        perimeter = new Array();
                    }
                    // draw closed polygons
                    ctx.fillStyle = "red";
                    for (var i = 0; i < perimeters.length; i++) {
                        var ps = perimeters[i];
                        ctx.beginPath();
                        ctx.moveTo(ps[0][0], ps[0][1]);
                        for (var j = 1; j < ps.length; j++) {
                            console.log("P");
                            ctx.lineTo(ps[j][0], ps[j][1]);
                            ctx.stroke();
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }, true);
        }
    </script>
</body>

</html>