<!-- 
    turkey: an Amazon Mechanical Turk turn-key segment tool.

    MIT License

    Copyright (c) 2018 Yanfeng Liu, Jay Carlson, Eric Psota, Lance C. PÃ©rez

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
 -->

<link rel="stylesheet" 
    href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" 
    integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
    crossorigin="anonymous">
<style>
    #parent {
        width: 1000px; 
        overflow: hidden;
        position: relative;
        background:#f5f5f5;
    }

    #myCanvas {
        position: absolute;
    }

    #pic{
        width: 100%;
        height: auto;
    }

    #text {
        width: 1000px;
    }

    #class {
        width: 200px;
        float:right;
    }
</style>

<div id="text" style="display:inline-block;vertical-align:top;">
    <h1 id="title">Instructions</h1>
    <select id="class" class="form-control"></select>
    <ul>
        <li>Click to draw points, polygon vertices, and links</li>
        <li>The blue toggle button indicates the current mode</li>
        <li>Press <strong>CTRL+Z</strong> to undo.</li>
        <li>Press <strong>C</strong> to close polygon in polygon mode.</li>
        <li>Press <strong>Reset</strong> to clear everything.</li>
        <li>Click <strong>Reset</strong> to clear everything.</li>
        <li>Click <strong>Reposition</strong> to center the image and zoom back.</li>
        <li>Dot mode indicates the location of the object with one click. </li>
        <li>Link mode indicates head (1st click) and tail (2nd click).</li>
        <li>Polygon mode draws the segmentation mask of the object.</li>
    </ul>

    <p id="buttons">
        <input class="btn btn-secondary" id="undo_button" type="button" value="Undo" />
        <input class="btn btn-danger" id="reset_button" type="button" value="Reset" />
        <input class="btn btn-danger" id="reposition_button" type="button" value="Reposition" />
        <input class="btn btn-info" id="mode_button" type="button" value="Dot Mode" />
    </p>

    <div>
        <!-- Coordinates input from user -->
        <input id="coordinates" name="coordinates" type="hidden" />
    </div>
</div>

<div id="parent">
    <div id="child">
        <canvas id="myCanvas">
        </canvas>
        <img id="pic" src="${img_url}" />
    </div>
</div>


<script id="turkey" type="text/javascript">
    var translateX, translateY, delta, scaleRatio, scaleDiff;
    var anchorX, anchorY, dragged, dragStart, dragX, dragY;
    var correctX, correctY, mouseX, mouseY;
    var child, parent, canvas, ctx, img;
    var annotations = new Array();
    var dragOffsetX = 0;
    var dragOffsetY = 0;
    var scalingOffsetX = 0;
    var scalingOffsetY = 0;
    var oldScale = newScale = 1.0;
    var canvas = 0;
    var firstPoint = true;
    var mode = "";
    var modes;
    var modeNum = 0;
    var classSelection;
    var dotSize = 8;
    var scaleTransform = 1;
    var translateTransform = [0, 0];
    var translateTransform_raw = [0, 0];

    var currentLink = {'class': [], 'mode': 'link', 'data' : []};
    var currentPolygon = {'class': [], 'mode': 'polygon', 'data' : []};;

    var handleScroll = function (evt) {
        getCorrectCoords(evt);
        delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.detail ? -evt.detail : 0;

        newScale += delta / 10;
        newScale = Math.max(newScale, 1.0);
        newScale = Math.min(newScale, 5.0);
        scaleRatio = newScale/oldScale;
        scaleDiff = newScale - oldScale;
        oldScale = scaleTransform = newScale;

        scalingOffsetX = (newScale - 1) * parent.offsetWidth/2;
        scalingOffsetY = (newScale - 1) * parent.offsetHeight/2;

        translateTransform_raw[0] -= (correctX - parent.offsetWidth/2)*scaleDiff;
        translateTransform_raw[1] -= (correctY - parent.offsetHeight/2)*scaleDiff;

        translateTransform[0] = translateTransform_raw[0]/newScale;
        translateTransform[1] = translateTransform_raw[1]/newScale;
        updateTransform();
    };

    function updateTransform(){
        child.style.transform = "";
        child.style.transform += 'scale(' + scaleTransform + ', ' + scaleTransform + ')';
        child.style.transform += 'translate(' + translateTransform[0] + 'px, ' + translateTransform[1] + 'px)';
    }

    function getCorrectCoords(evt) {
        mouseX = evt.clientX - parent.offsetLeft;
        mouseY = evt.clientY - parent.offsetTop + parent.scrollTop + window.pageYOffset;
        correctX = (mouseX + scalingOffsetX - translateTransform_raw[0]) / newScale;
        correctY = (mouseY + scalingOffsetY - translateTransform_raw[1]) / newScale;
        correctX = Math.round(correctX);
        correctY = Math.round(correctY);
    }

    var start = function () {
        parent = document.getElementById("parent");
        child = document.getElementById("child");
        canvas = document.getElementById("myCanvas");
        ctx = canvas.getContext("2d");
        img = document.getElementById("pic");
        modeButton = document.getElementById("mode_button");

        var mode_data = "${annotation_mode}";
        if(mode_data == ("$" +"{annotation_mode}")) // running in local demo mode
        {
            mode_data = "dot-link-polygon";
        }
        modes = mode_data.split('-');
        mode = modes[0];

        // generate select list options
        classSelection = document.getElementById("class");
        var classes_data = "${classes}";
        if(classes_data == ("$" +"{classes}")) // running in local demo mode
        {
            classes_data = "person-dog-house-car";
        }
        classes = classes_data.split('-');

        // populate list items and generate unique colors based on string hash
        var colors = {};
        classes.forEach((theClass) => {
            var option = document.createElement("option");
            var hue = Math.abs(theClass.hashCode() % 360)/360;
            var color = [hue, 1.0, 1.0];
            option.innerHTML = theClass;
            classSelection.appendChild(option);
            colors[theClass] = color;
        });

        classSelection.size = Math.min(10, classes.length);
        classSelection.selectedIndex = 0;

        modeButton.value = capitalize(mode);

        canvas.width = img.width;
        canvas.height = img.height;

        //initialize buttons
        document.getElementById("reset_button").addEventListener("click", function (e) {
            reset();
        });
        document.getElementById("reposition_button").addEventListener("click", function (e) {
            reposition();
        });
        document.getElementById("undo_button").addEventListener("click", function (e) {
            undo();
        });
        document.getElementById("mode_button").addEventListener("click", function (e) {
            toggleMode();
        });
        document.getElementById("submitButton").disabled = false;
        document.getElementById("buttons").appendChild(document.getElementById("submitButton"));

        child.addEventListener('DOMMouseScroll', handleScroll, false);
        child.addEventListener('mousewheel', handleScroll, false);

        var timeDownUp = null;

        canvas.addEventListener('mousedown', function (evt) {
            timeDownUp = new Date().getTime();
            // mouse down function go here
            anchorX = evt.clientX;
            anchorY = evt.clientY;
            dragged = false;
            dragStart = true;
        });


        canvas.addEventListener('mouseup', function (evt) {
            timeDownUp = new Date().getTime();
            getCorrectCoords(evt);
            if (!dragged) {
                switch (mode) {
                    case "dot": // dot mode
                        annotations.push({'class': getClass(), 'mode': 'dot', 'data' : [correctX, correctY]});
                        break;
                    case "link": // link mode
                        currentLink.class = getClass();
                        currentLink.data.push([correctX, correctY]);
                        if (firstPoint) {
                            firstPoint = false;
                        } else {
                            annotations.push(Object.assign({}, currentLink));
                            currentLink.data = new Array();
                            firstPoint = true;
                        }
                        break;
                    case "polygon": // polygon mode
                        currentPolygon.class = getClass();
                        currentPolygon.data.push([correctX, correctY]);
                }
            }
            updateGraphics();
            dragStart = false;
            // print coordinates
            if (annotations.length == 0) {
                document.getElementById('coordinates').value = '';
            } else {
                document.getElementById('coordinates').value = JSON.stringify(annotations);
            }
        });


        canvas.addEventListener('mousemove', function (evt) {
            var timeMove = new Date().getTime();
            timeDownUp += 30;
            if (timeMove > timeDownUp) {
                if (event.which === 1) {
                    // mouse move function go here
                    if (dragStart) {
                        dragged = true;
                        dragX = evt.clientX - anchorX;
                        dragY = evt.clientY - anchorY;
                        translateTransform_raw = [translateTransform_raw[0] + dragX, translateTransform_raw[1] + dragY];
                        translateTransform[0] = translateTransform_raw[0]/newScale;
                        translateTransform[1] = translateTransform_raw[1]/newScale;
                        updateTransform();
                        dragOffsetX += dragX;
                        dragOffsetY += dragY;
                        anchorX = evt.clientX;
                        anchorY = evt.clientY;
                    }
                }
            } else {
                timeDownUp = null;
            }
        });


        function toggleMode() {
            // clearAnnotations();
            modeNum += 1;
            if (modeNum >= modes.length) {
                modeNum = 0;
            }

            mode = modes[modeNum];
            modeButton.value = capitalize(mode);
        }
        function reset() {
            clearAnnotations();
            reposition();
            firstPoint = true;
        }

        function reposition(){
            child.style.transform = "";
            firstTransform = true; 
            scaleTransform = 1.0;
            translateTransform = [0, 0];
            transformQueue = new Array();
            newScale = 1.0;
            oldScale = 1.0;
            scaleRatio = 1.0;
            dragOffsetX = 0;
            dragOffsetY = 0;
            scalingOffsetX = 0;
            scalingOffsetY = 0;
        }

        function clearAnnotations() {
            perimeter = new Array();
            annotations = new Array();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function getClass() {
            return classSelection[classSelection.selectedIndex].innerHTML;
        }

        function updateGraphics(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i < annotations.length; i++){
                var ann = annotations[i];
                var corners = ann.data; 
                var color = colors[ann.class];
                var h = color[0];
                var s = color[1];
                var v = color[2];
                var rgbColors = HSVtoRGB(h, s, v);
                var r = rgbColors.r.toString();
                var g = rgbColors.g.toString();
                var b = rgbColors.b.toString();
                switch(ann.mode){
                    case "dot":
                        ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.fillRect(corners[0] - dotSize/2, corners[1] - dotSize/2, dotSize, dotSize);
                        break;
                    case "link": 
                        // draw complete links
                        ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.beginPath();
                        ctx.moveTo(corners[0][0], corners[0][1]);
                        ctx.lineTo(corners[1][0], corners[1][1]);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.fillRect(corners[0][0] - dotSize/2, corners[0][1] - dotSize/2, dotSize, dotSize);
                        ctx.fillRect(corners[1][0] - dotSize/2, corners[1][1] - dotSize/2, dotSize, dotSize);
                        break;
                    case "polygon": 
                        // draw complete polygons
                        ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 0.5)";
                        ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.beginPath();
                        ctx.moveTo(corners[0][0], corners[0][1]);
                        for (var j = 1; j < corners.length; j++) {
                            ctx.lineTo(corners[j][0], corners[j][1]);
                            ctx.stroke();
                        }
                        ctx.lineTo(corners[0][0], corners[0][1]);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fill();
                }
            }
            
            // draw current link
            if (currentLink.data.length != 0){
                var color = colors[currentLink.class];
                var h = color[0];
                var s = color[1];
                var v = color[2];
                var rgbColors = HSVtoRGB(h, s, v);
                var r = rgbColors.r.toString();
                var g = rgbColors.g.toString();
                var b = rgbColors.b.toString();
                ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                var dot = currentLink.data;
                ctx.fillRect(dot[0][0] - dotSize/2, dot[0][1] - dotSize/2, dotSize, dotSize);
            }

            // draw current polygon
            if (currentPolygon.data.length != 0){
                var color = colors[currentPolygon.class];
                var h = color[0];
                var s = color[1];
                var v = color[2];
                var rgbColors = HSVtoRGB(h, s, v);
                var r = rgbColors.r.toString();
                var g = rgbColors.g.toString();
                var b = rgbColors.b.toString();
                ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                var dots = currentPolygon.data;
                for (var j = 0; j < dots.length; j++) {
                    ctx.fillRect(dots[j][0] - dotSize/2, dots[j][1] - dotSize/2, dotSize, dotSize);
                }
            }
        }


        function undo() {
            switch(mode){
                case "dot":
                    annotations.pop();
                    break;
                case "link":
                    if (currentLink.data.length == 0){
                        annotations.pop();
                    } else {
                        currentLink.data = new Array();
                    }
                    break;
                case "polygon":
                    if (currentPolygon.data.length == 0){
                        annotations.pop();
                    } else {
                        currentPolygon.data.pop();
                    }
            }
            updateGraphics();
        }


        window.addEventListener("keydown", function (evt) {
            // Press E for "Mode toggle"
            if (evt.key == 'e') {
                toggleMode();
            }

            // Press ctrl + Z for "Undo"
            if ((evt.key == 'z') && (evt.ctrlKey)) {
                undo();
            }

            // Press C for "Close Polygon"
            if (evt.key == 'c') {
                if (currentPolygon.data.length > 2) {
                    currentPolygon.class = getClass();
                    annotations.push(Object.assign({}, currentPolygon));
                    currentPolygon.data = new Array();
                } else {
                    alert("Pressing C closes current polygon. Polygon with fewer than 3 vertices detected.")
                }
                // Update coordinates
                if (annotations.length == 0) {
                    document.getElementById('coordinates').value = '';
                } else {
                    document.getElementById('coordinates').value = JSON.stringify(annotations);
                }
            }
            updateGraphics();
        }, true);
    }

    window.onload = function () {
        start();
    }

function capitalize(string) 
{
    return string.charAt(0).toUpperCase() + string.slice(1);
}

String.prototype.hashCode = function() {
    var hash = 0;
    if (this.length == 0) {
        return hash;
    }
    for (var i = 0; i < this.length; i++) {
        var char = this.charCodeAt(i);
        hash = ((hash<<5)-hash)+char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}

function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

</script>