<!-- 
    turkey: an Amazon Mechanical Turk turn-key segment tool.

    MIT License

    Copyright (c) 2018 Yanfeng Liu, Jay Carlson, Eric Psota, Lance C. PÃ©rez

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
 -->

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
    crossorigin="anonymous">
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU"
    rel="stylesheet" />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<style>
    #parent {
        width: 1000px; 
        overflow: hidden;
        position: relative;
        background:#f5f5f5;
    }

    #child{
        margin: auto;
    }

    #myCanvas {
        position: absolute;
    }

    #pic{
        width: 100%;
        height: auto;
    }

    #text {
        width: 1000px;
    }

    .btn:hover {
        text-shadow:0px 0px 1px black;
    }

    .fixed_width {
        width: 130px !important;
    }

    #class {
        width: 200px;
        float:right;
    }

    #text {
        margin-bottom: 20px;
    }

    #buttons {
        margin-top: 20px;
    }
</style>

<div id="text" style="display:inline-block;vertical-align:top;">
    <button id="title" type="button" class="btn btn-outline-primary btn-lg">Instructions</button>
    <select id="class" class="form-control"></select>
    <ul id="instruction">
        <li>Click to annotate the image using up to three modes:</li>
        <ul>
            <li><strong>Dot mode</strong> indicates the location of the object with one click. </li>
            <li><strong>Link mode</strong> indicates head (1st click) and tail (2nd click).</li>
            <li><strong>Polygon mode</strong> draws the segmentation mask of the object.</li>
        </ul>
        <li>The <strong>Mode toggle</strong> button indicates the current mode</li>
        <li>Press <strong>CTRL+Z</strong> or click the <strong>Undo</strong> button to undo last deletion/annotation.</li>
        <li>Press <strong>C</strong> to close polygon in polygon mode.</li>
        <li>Click <strong>Delete/Annotate</strong> flip switch or press <strong>D</strong> to toggle between deleting and annotating.</li>
        <li>Click the <strong>Undo</strong> button to undo your last deletion/annotation depending on your current mode.</li>
        <li>Click the <strong>Reset</strong> button to clear all annotations.</li>
        <li>Click the <strong>Reposition</strong> button to center the image and reset zoom.</li>
        <li>Click the <strong>Submit</strong> button to finish current task.</li>
    </ul>

    <p id="buttons">
        <input class="btn btn-info fixed_width" id="mode_button" type="button" value = "Dot Mode" />
        <span id="delete_flip", class="btn-group btn-group-toggle" data-toggle="buttons">
            <label class="btn btn-outline-secondary disabled" type="radio" name="options" id="delete_button" autocomplete="off" checked> Delete </label>
            <label class="btn btn-primary" type="radio" name="options" id="annotate_button" autocomplete="off"> Annotate </label>
        </span>
        <input class="btn btn-secondary" id="undo_button" type="button" value = "Undo" />
        <input class="btn btn-danger" id="reset_button" type="button" value = "Reset" />
        <input class="btn btn-warning" id="reposition_button" type="button" value = "Reposition" />
    </p>

    
    
    <div>
        <!-- Coordinates input from user -->
        <input id="coordinates" name="coordinates" type="hidden" />
    </div>
</div>

<div id="parent">
    <div id="child">
        <canvas id="myCanvas">
        </canvas>
        <img id="pic" src="${img_url}" />
    </div>
</div>

<script id="turkey" type="text/javascript">
    var translateX, translateY, delta, scaleRatio, scaleDiff;
    var anchorX, anchorY, dragged, dragStart, dragX, dragY;
    var correctX, correctY, mouseX, mouseY;
    var child, parent, canvas, ctx, img;
    var annotations, modes, classSelection;
    var dragOffsetX = 0;
    var dragOffsetY = 0;
    var scalingOffsetX = 0;
    var scalingOffsetY = 0;
    var oldScale = newScale = 1.0;
    var firstPoint = true;
    var mode = "";
    var modeNum = 0;
    var dotSize = 4;
    var scaleTransform = 1;
    var translateTransform = [0, 0];
    var translateTransform_raw = [0, 0];
    var delete_mode = false;
    var delete_idx = -1;
    var trashcan = new Array();

    var currentLink = { 'class': [], 'mode': 'link', 'data': [] };
    var currentPolygon = { 'class': [], 'mode': 'polygon', 'data': [] };

    var handleScroll = function (evt) {
        getCorrectCoords(evt);
        delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.detail ? -evt.detail : 0;

        newScale += delta / 10;
        newScale = Math.max(newScale, 1.0);
        newScale = Math.min(newScale, 5.0);
        scaleRatio = newScale / oldScale;
        scaleDiff = newScale - oldScale;
        oldScale = scaleTransform = newScale;

        scalingOffsetX = (newScale - 1) * parent.offsetWidth / 2;
        scalingOffsetY = (newScale - 1) * parent.offsetHeight / 2;

        translateTransform_raw[0] -= (correctX - parent.offsetWidth / 2) * scaleDiff;
        translateTransform_raw[1] -= (correctY - parent.offsetHeight / 2) * scaleDiff;

        translateTransform[0] = translateTransform_raw[0] / newScale;
        translateTransform[1] = translateTransform_raw[1] / newScale;
        updateTransform();
    };

    function updateTransform() {
        child.style.transform = "";
        child.style.transform += 'scale(' + scaleTransform + ', ' + scaleTransform + ')';
        child.style.transform += 'translate(' + translateTransform[0] + 'px, ' + translateTransform[1] + 'px)';
    }

    function getCorrectCoords(evt) {
        mouseX = evt.clientX - parent.offsetLeft + parent.scrollLeft + window.pageXOffset;
        mouseY = evt.clientY - parent.offsetTop + parent.scrollTop + window.pageYOffset;
        correctX = (mouseX + scalingOffsetX - translateTransform_raw[0]) / newScale;
        correctY = (mouseY + scalingOffsetY - translateTransform_raw[1]) / newScale;
        correctX = Math.round(correctX);
        correctY = Math.round(correctY);
    }

    function getDeleteIdx(){
        var deleteIdx = -1;
        var min_dist = 1000000;
        var dist;
        for (var i = 0; i < annotations.length; i++) {
            var ann = annotations[i];
            var corners = ann.data;
            switch (ann.mode) {
                case "dot":
                    dist = getDist([correctX, correctY], corners);
                    if (dist < min_dist) {
                        min_dist = dist;
                        deleteIdx = i;
                    }
                    break;
                case "link":
                    for (var j = 0; j < 2; j++) {
                        dist = getDist([correctX, correctY], corners[j]);
                        if (dist < min_dist) {
                            min_dist = dist;
                            deleteIdx = i;
                        }
                    }
                    break;
                case "polygon":
                    for (var j = 1; j < corners.length; j++) {
                        dist = getDist([correctX, correctY], corners[j]);
                        if (dist < min_dist) {
                            min_dist = dist;
                            deleteIdx = i;
                        }
                    }
            }
        }
        return deleteIdx
    }

    function getDist(pair_a, pair_b) {
        var distance = Math.sqrt(Math.pow((pair_a[0] - pair_b[0]), 2) + Math.pow((pair_a[1] - pair_b[1]), 2));
        return distance;
    }

    function deep_copy(obj){
        return jQuery.extend(true, {}, obj);
    }

    var annotationsChanged = function()
    {
        if(annotations.length == 0)
        {
            $("#delete_button").addClass("disabled");
        } else {
            $("#delete_button").removeClass("disabled");
        }
    }

    var start = function () {
        parent = document.getElementById("parent");
        child = document.getElementById("child");
        canvas = document.getElementById("myCanvas");
        ctx = canvas.getContext("2d");
        img = document.getElementById("pic");
        modeButton = document.getElementById("mode_button");
        
        $('#instruction').slideUp(1500);

        $('#title').click(function () {
            $('#instruction').slideToggle();
        });

        annotations = "${annotations}";
        if (annotations == ("$" + "{annotations}")){
            annotations = [];
        }

        annotations.push = function(obj) {
            Array.prototype.push.call(annotations, obj);
            annotationsChanged();
        }

        annotations.splice = function(idx, numElements) {
            Array.prototype.splice.call(annotations, idx, numElements);
            annotationsChanged();
        }

        var mode_data = "${annotation_mode}";
        if (mode_data == ("$" + "{annotation_mode}")) // running in local demo mode
        {
            mode_data = "dot-link-polygon";
        }
        modes = mode_data.split('-');
        mode = modes[0];


        canvas.style.cursor = "crosshair";

        // generate select list options
        classSelection = document.getElementById("class");
        var classes_data = "${classes}";
        if (classes_data == ("$" + "{classes}")) // running in local demo mode
        {
            classes_data = "person-dog-house-car";
        }
        classes = classes_data.split('-');

        // populate list items and generate unique colors based on string hash
        var colors = {};
        classes.forEach((theClass) => {
            var option = document.createElement("option");
            var hue = Math.abs(theClass.hashCode() % 360) / 360;
            var color = [hue, 1.0, 1.0];
            option.innerHTML = theClass;
            classSelection.appendChild(option);
            colors[theClass] = color;
        });

        classSelection.size = Math.min(10, classes.length);
        classSelection.selectedIndex = 0;

        modeButton.value = 'Mode: ' + capitalize(mode);

        canvas.width = img.width;
        canvas.height = img.height;

        //initialize buttons
        document.getElementById("reset_button").addEventListener("click", function (e) {
            reset();
        });
        document.getElementById("reposition_button").addEventListener("click", function (e) {
            reposition();
        });
        document.getElementById("undo_button").addEventListener("click", function (e) {
            undo();
        });
        document.getElementById("mode_button").addEventListener("click", function (e) {
            toggleMode();
        });
        document.getElementById("delete_button").addEventListener("click", function (e) {
            setDeleteMode(true);
        });
        document.getElementById("annotate_button").addEventListener("click", function (e) {
            setDeleteMode(false);
        });
        document.getElementById("submitButton").disabled = false;
        document.getElementById("buttons").appendChild(document.getElementById("submitButton"));

        child.addEventListener('DOMMouseScroll', handleScroll, false);
        child.addEventListener('mousewheel', handleScroll, false);

        var timeDownUp = null;

        canvas.addEventListener('mouseout', function(evt) {
            dragStart = false;
            dragged = false; 
        });

        canvas.addEventListener('mousedown', function (evt) {
            timeDownUp = new Date().getTime();
            // mouse down function go here
            anchorX = evt.clientX;
            anchorY = evt.clientY;
            dragged = false;
            dragStart = true;
        });

        canvas.addEventListener('mouseup', function (evt) {
            timeDownUp = new Date().getTime();
            getCorrectCoords(evt);
            if (!dragged) {
                if (getDeleteMode() == true) {
                    if (delete_idx > -1) {
                        var ann_copy = deep_copy(annotations[delete_idx]);
                        trashcan.push(ann_copy);
                        annotations.splice(delete_idx, 1);
                        getCorrectCoords(evt);
                        delete_idx = getDeleteIdx();
                        if(annotations.length == 0)
                            // no more to delete, go back to annotate mode
                            setDeleteMode(false);
                    }
                } else {
                    switch (mode) {
                        case "dot": // dot mode
                            annotations.push({ 'class': getClass(), 'mode': 'dot', 'data': [correctX, correctY] });
                            break;
                        case "link": // link mode
                            currentLink.class = getClass();
                            currentLink.data.push([correctX, correctY]);
                            if (firstPoint) {
                                firstPoint = false;
                            } else {
                                annotations.push(Object.assign({}, currentLink));
                                currentLink.data = new Array();
                                firstPoint = true;
                            }
                            break;
                        case "polygon": // polygon mode
                            currentPolygon.class = getClass();
                            currentPolygon.data.push([correctX, correctY]);
                    }
                }
            }
            updateGraphics();
            dragStart = false;
            // print coordinates
            if (annotations.length == 0) {
                document.getElementById('coordinates').value = '';
            } else {
                document.getElementById('coordinates').value = JSON.stringify(annotations);
            }
        });


        canvas.addEventListener('mousemove', function (evt) {
            var timeMove = new Date().getTime();
            timeDownUp += 30;
            if (timeMove > timeDownUp) {
                if (event.which === 1) {
                    if (dragStart) {
                        dragged = true;
                        dragX = evt.clientX - anchorX;
                        dragY = evt.clientY - anchorY;
                        translateTransform_raw = [translateTransform_raw[0] + dragX, translateTransform_raw[1] + dragY];
                        translateTransform[0] = translateTransform_raw[0] / newScale;
                        translateTransform[1] = translateTransform_raw[1] / newScale;
                        updateTransform();
                        dragOffsetX += dragX;
                        dragOffsetY += dragY;
                        anchorX = evt.clientX;
                        anchorY = evt.clientY;
                    } else {
                        if (getDeleteMode() == true) {
                            getCorrectCoords(evt);
                            delete_idx = getDeleteIdx();
                            updateGraphics();
                        }
                    }
                }
            } else {
                timeDownUp = null;
            }
        });


        function toggleMode() {
            // clearAnnotations();
            modeNum += 1;
            if (modeNum >= modes.length) {
                modeNum = 0;
            }
            setDeleteMode(false);
            mode = modes[modeNum];
            modeButton.value = 'Mode: ' + capitalize(mode);
            if (mode == "polygon"){
                $("#mode_button").popover('toggle');
            }
        }

        function toggleDelete () {
            setDeleteMode(!getDeleteMode());
        }

        function getDeleteMode()
        {
            return delete_mode;
        }

        function setDeleteMode(deleteMode) {
            if( deleteMode == true && $("#delete_button").hasClass("disabled"))
            {
                return;
            }
            
            delete_mode = deleteMode;
            if (delete_mode == false) {
                // annotate mode
                canvas.style.cursor = "crosshair";
                $("#delete_button").removeClass('btn-primary');
                $("#delete_button").addClass('btn-outline-secondary');

                $("#annotate_button").removeClass('btn-outline-secondary');
                $("#annotate_button").addClass('btn-primary');
                updateGraphics();
            } else {
                // delete mode
                delete_idx = getDeleteIdx();
                canvas.style.cursor = "pointer";
                $("#annotate_button").removeClass('btn-primary');
                $("#annotate_button").addClass('btn-outline-secondary');

                $("#delete_button").removeClass('btn-outline-secondary');
                $("#delete_button").addClass('btn-primary');
                updateGraphics();
            }

        }

        function reset() {
            clearAnnotations();
            reposition();
            firstPoint = true;
        }

        function reposition() {
            child.style.transform = "";
            scaleTransform = 1.0;
            translateTransform = [0, 0];
            translateTransform_raw = [0, 0];
            newScale = 1.0;
            oldScale = 1.0;
            scaleRatio = 1.0;
            scaleDiff = 0;
            dragOffsetX = 0;
            dragOffsetY = 0;
            scalingOffsetX = 0;
            scalingOffsetY = 0;
        }

        function clearAnnotations() {
            annotations = new Array();
            trashcan = new Array();
            currentLink = { 'class': [], 'mode': 'link', 'data': [] };
            currentPolygon = { 'class': [], 'mode': 'polygon', 'data': [] };
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function getClass() {
            return classSelection[classSelection.selectedIndex].innerHTML;
        }

        /**
        *   Redraw all annotations
        */
        function updateGraphics() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i < annotations.length; i++) {
                var ann = annotations[i];
                var corners = ann.data;
                var r, g, b;
                if (getDeleteMode() == true && delete_idx == i) {
                    r = g = b = 0.5;
                } else {
                    var color = colors[ann.class];
                    var h = color[0];
                    var s = color[1];
                    var v = color[2];
                    var rgbColors = HSVtoRGB(h, s, v);
                    r = rgbColors.r.toString();
                    g = rgbColors.g.toString();
                    b = rgbColors.b.toString();
                }
                switch (ann.mode) {
                    case "dot":
                        ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.fillRect(corners[0] - dotSize / 2, corners[1] - dotSize / 2, dotSize, dotSize);
                        break;
                    case "link":
                        // draw complete links
                        ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.beginPath();
                        ctx.moveTo(corners[0][0], corners[0][1]);
                        ctx.lineTo(corners[1][0], corners[1][1]);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.fillRect(corners[0][0] - dotSize / 2, corners[0][1] - dotSize / 2, dotSize, dotSize);
                        ctx.fillRect(corners[1][0] - dotSize / 2, corners[1][1] - dotSize / 2, dotSize, dotSize);
                        break;
                    case "polygon":
                        // draw complete polygons
                        ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 0.5)";
                        ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                        ctx.beginPath();
                        ctx.moveTo(corners[0][0], corners[0][1]);
                        for (var j = 1; j < corners.length; j++) {
                            ctx.lineTo(corners[j][0], corners[j][1]);
                            ctx.stroke();
                        }
                        ctx.lineTo(corners[0][0], corners[0][1]);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fill();
                }
            }

            // draw current link
            if (currentLink.data.length != 0) {
                var color = colors[currentLink.class];
                var h = color[0];
                var s = color[1];
                var v = color[2];
                var rgbColors = HSVtoRGB(h, s, v);
                var r = rgbColors.r.toString();
                var g = rgbColors.g.toString();
                var b = rgbColors.b.toString();
                ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                var dot = currentLink.data;
                ctx.fillRect(dot[0][0] - dotSize / 2, dot[0][1] - dotSize / 2, dotSize, dotSize);
            }

            // draw current polygon
            if (currentPolygon.data.length != 0) {
                var color = colors[currentPolygon.class];
                var h = color[0];
                var s = color[1];
                var v = color[2];
                var rgbColors = HSVtoRGB(h, s, v);
                var r = rgbColors.r.toString();
                var g = rgbColors.g.toString();
                var b = rgbColors.b.toString();
                ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                var dots = currentPolygon.data;
                for (var j = 0; j < dots.length; j++) {
                    ctx.fillRect(dots[j][0] - dotSize / 2, dots[j][1] - dotSize / 2, dotSize, dotSize);
                }
                // draw lines connecting the dots
                ctx.beginPath();
                ctx.moveTo(dots[0][0], dots[0][1]);
                for (var j = 1; j < dots.length; j++) {
                    ctx.lineTo(dots[j][0], dots[j][1]);
                    ctx.stroke();
                }
                ctx.stroke();
                ctx.closePath();
            }
        }

        // depending on mode, either undo deletion or undo annotation
        function undo() {
            if (getDeleteMode() == true){
                if (trashcan.length > 0) {
                    annotations.push(trashcan.pop());
                }
            } else {
                switch (mode) {
                    case "dot":
                        annotations.pop();
                        break;
                    case "link":
                        if (currentLink.data.length == 0) {
                            annotations.pop();
                        } else {
                            currentLink.data = new Array();
                        }
                        break;
                    case "polygon":
                        if (currentPolygon.data.length == 0) {
                            annotations.pop();
                        } else {
                            currentPolygon.data.pop();
                        }
                }
            }
            updateGraphics();
        }

        window.addEventListener("keydown", function (evt) {
            // Press E for "Mode toggle"
            if (evt.key == 'e') {
                toggleMode();
            }

            // Press ctrl + Z for "Undo"
            if ((evt.key == 'z') && (evt.ctrlKey)) {
                undo();
            }

            // Press D for "Delete"
            if ((evt.key == 'd')) {
                toggleDelete();
            }

            // Press C for "Close Polygon"
            if (evt.key == 'c') {
                if (currentPolygon.data.length > 2) {
                    currentPolygon.class = getClass();
                    annotations.push(Object.assign({}, currentPolygon));
                    currentPolygon.data = new Array();
                } else {
                    alert("Pressing C closes current polygon. Polygon with fewer than 3 vertices detected.")
                }
                // Update coordinates
                if (annotations.length == 0) {
                    document.getElementById('coordinates').value = '';
                } else {
                    document.getElementById('coordinates').value = JSON.stringify(annotations);
                }
            }
            updateGraphics();
        }, true);
    }

    window.onload = function () {
        start();
    }

    function capitalize(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    String.prototype.hashCode = function () {
        var hash = 0;
        if (this.length == 0) {
            return hash;
        }
        for (var i = 0; i < this.length; i++) {
            var char = this.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
    }

    function HSVtoRGB(h, s, v) {
        var r, g, b, i, f, p, q, t;
        if (arguments.length === 1) {
            s = h.s, v = h.v, h = h.h;
        }
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }
        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    }

</script>